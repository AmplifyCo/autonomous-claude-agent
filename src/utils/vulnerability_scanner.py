"""Vulnerability scanner for Python packages and system updates."""

import asyncio
import json
import logging
from typing import List, Dict, Any, Optional
from datetime import datetime
from dataclasses import dataclass

logger = logging.getLogger(__name__)


@dataclass
class Vulnerability:
    """Represents a package vulnerability."""
    package: str
    installed_version: str
    vulnerable_versions: str
    advisory: str
    severity: str  # critical, high, medium, low
    fixed_version: Optional[str] = None
    cve_id: Optional[str] = None


class VulnerabilityScanner:
    """Scans for vulnerabilities in Python packages and system packages."""

    def __init__(self, bash_tool=None):
        """Initialize vulnerability scanner.

        Args:
            bash_tool: BashTool instance for running commands
        """
        self.bash_tool = bash_tool
        self.last_scan = None
        self.vulnerabilities: List[Vulnerability] = []

    async def scan_python_packages(self) -> List[Vulnerability]:
        """Scan Python packages for vulnerabilities using pip-audit.

        Returns:
            List of vulnerabilities found
        """
        logger.info("Scanning Python packages for vulnerabilities...")
        vulnerabilities = []

        try:
            import subprocess
            # Run pip-audit directly via subprocess (avoids bash tool security filters)
            try:
                proc = await asyncio.get_event_loop().run_in_executor(
                    None,
                    lambda: subprocess.run(
                        ["pip-audit", "--format", "json", "--desc", "on"],
                        capture_output=True, text=True, timeout=300
                    )
                )
                if proc.returncode == 0:
                    vulnerabilities.extend(self._parse_pip_audit(proc.stdout))
                else:
                    logger.info("pip-audit not available, trying safety...")
                    proc = await asyncio.get_event_loop().run_in_executor(
                        None,
                        lambda: subprocess.run(
                            ["safety", "check", "--json"],
                            capture_output=True, text=True, timeout=300
                        )
                    )
                    if proc.returncode == 0:
                        vulnerabilities.extend(self._parse_safety(proc.stdout))
                    else:
                        logger.info("Neither pip-audit nor safety available — skipping vulnerability scan")
            except FileNotFoundError:
                logger.info("No vulnerability scanner installed (pip-audit/safety) — skipping")

        except Exception as e:
            logger.error(f"Error scanning Python packages: {e}")

        self.vulnerabilities = vulnerabilities
        self.last_scan = datetime.now()

        logger.info(f"Found {len(vulnerabilities)} Python package vulnerabilities")
        return vulnerabilities

    async def scan_system_packages(self) -> List[Dict[str, str]]:
        """Scan system packages for available security updates.

        Returns:
            List of packages with security updates
        """
        logger.info("Scanning for system security updates...")
        updates = []

        try:
            import subprocess
            import shutil

            # Detect package manager: dnf (Amazon Linux 2023) > yum > apt
            if shutil.which("dnf"):
                cmd = ["dnf", "check-update", "--security", "--quiet"]
                update_rc = 100
            elif shutil.which("yum"):
                cmd = ["yum", "check-update", "--security", "--quiet"]
                update_rc = 100
            elif shutil.which("apt"):
                cmd = ["apt", "list", "--upgradable"]
                update_rc = 0
            else:
                logger.info("No supported package manager found — skipping system scan")
                return updates

            proc = await asyncio.get_event_loop().run_in_executor(
                None,
                lambda: subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            )

            if proc.returncode == update_rc:
                for line in proc.stdout.strip().split('\n'):
                    if line and not line.startswith('#'):
                        parts = line.split()
                        if len(parts) >= 2:
                            updates.append({
                                "package": parts[0],
                                "version": parts[1],
                                "type": "security"
                            })

        except Exception as e:
            logger.error(f"Error scanning system packages: {e}")

        logger.info(f"Found {len(updates)} system security updates")
        return updates

    async def get_outdated_packages(self) -> List[Dict[str, str]]:
        """Get list of outdated Python packages.

        Returns:
            List of outdated packages
        """
        logger.info("Checking for outdated Python packages...")

        outdated = []

        try:
            result = await self.bash_tool.execute(
                "pip list --outdated --format json",
                timeout=60
            )

            if result.success:
                outdated = json.loads(result.output)

        except Exception as e:
            logger.error(f"Error getting outdated packages: {e}")

        logger.info(f"Found {len(outdated)} outdated Python packages")
        return outdated

    def _parse_pip_audit(self, output: str) -> List[Vulnerability]:
        """Parse pip-audit JSON output.

        Args:
            output: JSON output from pip-audit

        Returns:
            List of Vulnerability objects
        """
        vulnerabilities = []

        try:
            data = json.loads(output)

            for vuln_data in data.get("vulnerabilities", []):
                vuln = Vulnerability(
                    package=vuln_data.get("name", "unknown"),
                    installed_version=vuln_data.get("version", "unknown"),
                    vulnerable_versions=vuln_data.get("vulnerable_versions", ""),
                    advisory=vuln_data.get("description", "No description"),
                    severity=vuln_data.get("severity", "unknown").lower(),
                    fixed_version=vuln_data.get("fix_versions", [None])[0],
                    cve_id=vuln_data.get("id", None)
                )
                vulnerabilities.append(vuln)

        except json.JSONDecodeError:
            logger.error("Failed to parse pip-audit output")
        except Exception as e:
            logger.error(f"Error parsing pip-audit: {e}")

        return vulnerabilities

    def _parse_safety(self, output: str) -> List[Vulnerability]:
        """Parse safety JSON output.

        Args:
            output: JSON output from safety

        Returns:
            List of Vulnerability objects
        """
        vulnerabilities = []

        try:
            data = json.loads(output)

            for vuln_data in data:
                vuln = Vulnerability(
                    package=vuln_data[0],
                    installed_version=vuln_data[2],
                    vulnerable_versions=vuln_data[1],
                    advisory=vuln_data[3],
                    severity="high",  # safety doesn't provide severity
                    cve_id=vuln_data[4] if len(vuln_data) > 4 else None
                )
                vulnerabilities.append(vuln)

        except json.JSONDecodeError:
            logger.error("Failed to parse safety output")
        except Exception as e:
            logger.error(f"Error parsing safety: {e}")

        return vulnerabilities

    def get_critical_vulnerabilities(self) -> List[Vulnerability]:
        """Get only critical and high severity vulnerabilities.

        Returns:
            List of critical/high vulnerabilities
        """
        return [
            v for v in self.vulnerabilities
            if v.severity in ["critical", "high"]
        ]

    def get_scan_summary(self) -> Dict[str, Any]:
        """Get summary of last scan.

        Returns:
            Dictionary with scan summary
        """
        severity_counts = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "unknown": 0
        }

        for vuln in self.vulnerabilities:
            severity_counts[vuln.severity] = severity_counts.get(vuln.severity, 0) + 1

        return {
            "last_scan": self.last_scan.isoformat() if self.last_scan else None,
            "total_vulnerabilities": len(self.vulnerabilities),
            "severity_breakdown": severity_counts,
            "critical_packages": [
                v.package for v in self.get_critical_vulnerabilities()
            ]
        }
